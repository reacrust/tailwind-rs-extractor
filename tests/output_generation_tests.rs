use tailwind_extractor::{ExtractArgs, extract, TailwindExtractor, ManifestBuilder};
use tempfile::tempdir;
use std::fs;
use serde_json::Value;

#[test]
fn test_css_header_generation() {
    let mut extractor = TailwindExtractor::new();
    
    // Test with empty classes
    let css = extractor.generate_css(false).unwrap();
    assert!(css.contains("Generated by tailwind-extractor-cli"));
    assert!(css.contains("No Tailwind classes found"));
    
    // Test with classes
    extractor.add_class("p-4", "test.js").unwrap();
    let css = extractor.generate_css(false).unwrap();
    assert!(css.contains("Generated by tailwind-extractor-cli"));
    assert!(css.contains("DO NOT EDIT"));
}

#[test]
fn test_css_minification() {
    let mut extractor = TailwindExtractor::new();
    extractor.add_class("p-4", "test.js").unwrap();
    extractor.add_class("m-2", "test.js").unwrap();
    
    // Generate non-minified CSS
    let css_normal = extractor.generate_css(false).unwrap();
    
    // Generate minified CSS
    let css_minified = extractor.generate_css(true).unwrap();
    
    // Minified should be smaller
    assert!(css_minified.len() < css_normal.len());
    
    // Minified should preserve header comment
    assert!(css_minified.starts_with("/* Generated by tailwind-extractor-cli"));
    
    // Minified should have less whitespace
    assert!(css_normal.matches('\n').count() > css_minified.matches('\n').count());
}

#[test]
fn test_manifest_structure() {
    let mut builder = ManifestBuilder::new();
    
    let mut classes = std::collections::HashMap::new();
    classes.insert("bg-blue-500".to_string(), vec![
        "src/app.js:10:15".to_string(),
        "src/component.js:20:5".to_string(),
    ]);
    classes.insert("text-white".to_string(), vec![
        "src/app.js:11:20".to_string(),
    ]);
    
    let manifest = builder
        .with_build_mode("production".to_string())
        .with_files_processed(5)
        .with_classes_extracted(2)
        .with_class_info(classes)
        .build(1024, Some(512));
    
    let json = manifest.to_json();
    
    // Check metadata
    assert_eq!(json["metadata"]["version"], "1.0.0");
    assert_eq!(json["metadata"]["files_processed"], 5);
    assert_eq!(json["metadata"]["classes_extracted"], 2);
    assert_eq!(json["metadata"]["build_mode"], "production");
    assert!(!json["metadata"]["obfuscation_enabled"].as_bool().unwrap());
    
    // Check classes
    assert_eq!(json["classes"]["bg-blue-500"]["count"], 2);
    assert_eq!(json["classes"]["text-white"]["count"], 1);
    
    // Check statistics
    assert!(json["statistics"].is_object());
    assert_eq!(json["statistics"]["css_size_bytes"], 1024);
    assert_eq!(json["statistics"]["minified_size_bytes"], 512);
}

#[tokio::test]
async fn test_atomic_file_writes() {
    let temp_dir = tempdir().unwrap();
    
    // Create test file
    let js_file = temp_dir.path().join("test.js");
    fs::write(&js_file, r#"
        const className = "p-4 m-2 bg-white";
    "#).unwrap();
    
    let output_css = temp_dir.path().join("output.css");
    let output_manifest = temp_dir.path().join("manifest.json");
    
    let args = ExtractArgs {
        input: vec![format!("{}/*.js", temp_dir.path().display())],
        exclude: vec![],
        output_css: output_css.clone(),
        output_manifest: output_manifest.clone(),
        config: None,
        obfuscate: false,
        minify: false,
        watch: false,
        verbose: false,
        dry_run: false,
        no_preflight: false,
        transform: false,
        jobs: None,
    };
    
    // Run extraction
    let result = extract(args).await.unwrap();
    
    // Verify files were created
    assert!(output_css.exists());
    assert!(output_manifest.exists());
    
    // Verify no temporary files remain
    assert!(!output_css.with_extension(".tmp").exists());
    assert!(!output_manifest.with_extension(".tmp").exists());
    
    // Verify CSS content
    let css = fs::read_to_string(&output_css).unwrap();
    assert!(css.contains("Generated by tailwind-extractor-cli"));
    
    // Verify manifest is valid JSON
    let manifest_str = fs::read_to_string(&output_manifest).unwrap();
    let manifest: Value = serde_json::from_str(&manifest_str).unwrap();
    assert!(manifest["metadata"].is_object());
}

#[tokio::test]
async fn test_manifest_with_obfuscation() {
    let temp_dir = tempdir().unwrap();
    
    // Create test file
    let js_file = temp_dir.path().join("test.js");
    fs::write(&js_file, r#"
        const className = "bg-blue-500 text-white p-4";
    "#).unwrap();
    
    let output_css = temp_dir.path().join("output.css");
    let output_manifest = temp_dir.path().join("manifest.json");
    
    let args = ExtractArgs {
        input: vec![format!("{}/*.js", temp_dir.path().display())],
        exclude: vec![],
        output_css,
        output_manifest: output_manifest.clone(),
        config: None,
        obfuscate: true, // Enable obfuscation
        minify: false,
        watch: false,
        verbose: false,
        dry_run: false,
        no_preflight: false,
        transform: false,
        jobs: None,
    };
    
    // Run extraction
    extract(args).await.unwrap();
    
    // Read and parse manifest
    let manifest_str = fs::read_to_string(&output_manifest).unwrap();
    let manifest: Value = serde_json::from_str(&manifest_str).unwrap();
    
    // Check obfuscation is enabled
    assert!(manifest["metadata"]["obfuscation_enabled"].as_bool().unwrap());
    
    // Check mappings exist
    assert!(manifest["mappings"].is_object());
    let mappings = manifest["mappings"].as_object().unwrap();
    assert!(!mappings.is_empty());
    
    // Verify mappings are deterministic (same input -> same output)
    if let Some(mapping1) = mappings.get("bg-blue-500") {
        // Default prefix is '_' in the config
        let mapping_str = mapping1.as_str().unwrap();
        assert!(!mapping_str.is_empty());
        assert!(mapping_str.len() > 1); // Should be obfuscated
    }
}

#[tokio::test]
async fn test_manifest_statistics() {
    let temp_dir = tempdir().unwrap();
    
    // Create multiple test files
    for i in 0..3 {
        let js_file = temp_dir.path().join(format!("test{}.js", i));
        fs::write(&js_file, format!(r#"
            const className{} = "p-4 m-2 bg-white hover:bg-gray-100";
        "#, i)).unwrap();
    }
    
    let output_css = temp_dir.path().join("output.css");
    let output_manifest = temp_dir.path().join("manifest.json");
    
    let args = ExtractArgs {
        input: vec![format!("{}/*.js", temp_dir.path().display())],
        exclude: vec![],
        output_css: output_css.clone(),
        output_manifest: output_manifest.clone(),
        config: None,
        obfuscate: false,
        minify: true,
        watch: false,
        verbose: false,
        dry_run: false,
        no_preflight: false,
        transform: false,
        jobs: None,
    };
    
    // Run extraction
    extract(args).await.unwrap();
    
    // Read and parse manifest
    let manifest_str = fs::read_to_string(&output_manifest).unwrap();
    let manifest: Value = serde_json::from_str(&manifest_str).unwrap();
    
    // Check statistics
    assert!(manifest["statistics"].is_object());
    let stats = &manifest["statistics"];
    
    assert_eq!(stats["files_matched"], 3);
    assert!(stats["css_size_bytes"].as_u64().unwrap() > 0);
    assert!(stats["files_with_classes"].as_u64().unwrap() > 0);
    
    // Check top classes
    assert!(stats["top_classes"].is_array());
    let top_classes = stats["top_classes"].as_array().unwrap();
    assert!(!top_classes.is_empty());
    
    // Check that we have multiple occurrences of classes
    // The actual top class depends on what tailwind-rs validates
    assert!(top_classes[0]["count"].as_u64().unwrap() >= 1);
}

#[tokio::test]
async fn test_pretty_vs_compact_json() {
    let temp_dir = tempdir().unwrap();
    
    // Create test file
    let js_file = temp_dir.path().join("test.js");
    fs::write(&js_file, r#"const c = "p-4";"#).unwrap();
    
    let output_css = temp_dir.path().join("output.css");
    let output_manifest_pretty = temp_dir.path().join("manifest_pretty.json");
    let output_manifest_compact = temp_dir.path().join("manifest_compact.json");
    
    // Test pretty print (default)
    let args_pretty = ExtractArgs {
        input: vec![format!("{}/*.js", temp_dir.path().display())],
        exclude: vec![],
        output_css: output_css.clone(),
        output_manifest: output_manifest_pretty.clone(),
        config: None,
        obfuscate: false,
        minify: false, // Not minified = pretty JSON
        watch: false,
        verbose: false,
        dry_run: false,
        no_preflight: false,
        transform: false,
        jobs: None,
    };
    
    extract(args_pretty).await.unwrap();
    
    // Test compact
    let args_compact = ExtractArgs {
        input: vec![format!("{}/*.js", temp_dir.path().display())],
        exclude: vec![],
        output_css,
        output_manifest: output_manifest_compact.clone(),
        config: None,
        obfuscate: false,
        minify: true, // Minified = compact JSON
        watch: false,
        verbose: false,
        dry_run: false,
        no_preflight: false,
        transform: false,
        jobs: None,
    };
    
    extract(args_compact).await.unwrap();
    
    let pretty = fs::read_to_string(&output_manifest_pretty).unwrap();
    let compact = fs::read_to_string(&output_manifest_compact).unwrap();
    
    // Pretty should have newlines and indentation
    assert!(pretty.contains('\n'));
    assert!(pretty.contains("  "));
    
    // Compact should be smaller
    assert!(compact.len() < pretty.len());
    assert!(!compact.contains("\n  "));
    
    // Both should parse to same JSON
    let json_pretty: Value = serde_json::from_str(&pretty).unwrap();
    let json_compact: Value = serde_json::from_str(&compact).unwrap();
    assert_eq!(json_pretty["metadata"]["version"], json_compact["metadata"]["version"]);
}

#[test]
fn test_deterministic_output() {
    let mut extractor1 = TailwindExtractor::new();
    let mut extractor2 = TailwindExtractor::new();
    
    // Add same classes in same order
    let classes = vec!["p-4", "m-2", "bg-blue-500", "text-white"];
    for class in &classes {
        extractor1.add_class(class, "test.js").unwrap();
        extractor2.add_class(class, "test.js").unwrap();
    }
    
    // Generate CSS
    let css1 = extractor1.generate_css(true).unwrap();
    let css2 = extractor2.generate_css(true).unwrap();
    
    // Remove timestamps from headers for comparison
    let css1_no_timestamp = remove_timestamp(&css1);
    let css2_no_timestamp = remove_timestamp(&css2);
    
    // Should produce identical output
    assert_eq!(css1_no_timestamp, css2_no_timestamp);
}

fn remove_timestamp(css: &str) -> String {
    // Remove timestamp from header comment for comparison
    let re = regex::Regex::new(r"at \d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2} UTC").unwrap();
    re.replace_all(css, "at [TIMESTAMP]").to_string()
}