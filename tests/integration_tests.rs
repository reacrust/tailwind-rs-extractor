use std::path::PathBuf;
use tailwind_extractor::{extract, ExtractArgs};
use tempfile::TempDir;

fn create_test_args(input_dir: &str, output_dir: &TempDir) -> ExtractArgs {
    ExtractArgs {
        input: vec![format!("{}/**/*.mjs", input_dir)],
        exclude: vec![],
        output_css: output_dir.path().join("output.css"),
        output_manifest: output_dir.path().join("manifest.json"),
        config: None,
        obfuscate: false,
        minify: false,
        watch: false,
        verbose: false,
        dry_run: false,
        jobs: Some(1),
        no_preflight: false,
        transform: false,
    }
}

#[tokio::test]
async fn test_full_extraction_pipeline() {
    let fixtures_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("tests")
        .join("fixtures");
    let output_dir = TempDir::new().unwrap();
    
    let args = create_test_args(fixtures_dir.to_str().unwrap(), &output_dir);
    
    let result = extract(args).await.unwrap();
    
    // Verify extraction result
    assert!(result.total_files_processed > 0);
    assert!(result.total_classes > 0);
    assert!(!result.css_content.is_empty());
    
    // Verify manifest structure
    assert!(result.manifest.get("metadata").is_some());
    assert!(result.manifest.get("classes").is_some());
    assert!(result.manifest["metadata"].get("classes_extracted").is_some());
    
    // Check that specific classes were found
    let classes = result.manifest["classes"].as_object().unwrap();
    let class_strings: Vec<String> = classes
        .keys()
        .map(|k| k.to_string())
        .collect();
    
    assert!(class_strings.contains(&"bg-blue-500".to_string()));
    assert!(class_strings.contains(&"text-white".to_string()));
    assert!(class_strings.contains(&"hover:bg-blue-600".to_string()));
    assert!(class_strings.contains(&"rounded-lg".to_string()));
}

#[tokio::test]
async fn test_extraction_with_exclusion() {
    let fixtures_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("tests")
        .join("fixtures");
    let output_dir = TempDir::new().unwrap();
    
    let mut args = create_test_args(fixtures_dir.to_str().unwrap(), &output_dir);
    // Exclude React components
    args.exclude = vec!["**/react_*.mjs".to_string()];
    
    let result = extract(args).await.unwrap();
    
    // Should have processed fewer files
    assert!(result.total_files_processed > 0);
    
    // Check that React-specific classes are not present
    let classes = result.manifest["classes"].as_object().unwrap();
    let class_strings: Vec<String> = classes
        .keys()
        .map(|k| k.to_string())
        .collect();
    
    // These are from react_component.mjs which should be excluded
    assert!(!class_strings.contains(&"transition-colors".to_string()));
    
    // These are from rescript_output.res.mjs which should be included
    assert!(class_strings.contains(&"min-h-screen".to_string()));
}

#[tokio::test]
async fn test_dry_run_mode() {
    let fixtures_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("tests")
        .join("fixtures");
    let output_dir = TempDir::new().unwrap();
    
    let mut args = create_test_args(fixtures_dir.to_str().unwrap(), &output_dir);
    args.dry_run = true;
    
    let css_path = args.output_css.clone();
    let manifest_path = args.output_manifest.clone();
    
    let result = extract(args).await.unwrap();
    
    // Should extract successfully
    assert!(result.total_classes > 0);
    
    // But should not write files in dry-run mode
    assert!(!css_path.exists());
    assert!(!manifest_path.exists());
}

#[tokio::test]
async fn test_output_files_created() {
    let fixtures_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("tests")
        .join("fixtures");
    let output_dir = TempDir::new().unwrap();
    
    let args = create_test_args(fixtures_dir.to_str().unwrap(), &output_dir);
    
    let css_path = args.output_css.clone();
    let manifest_path = args.output_manifest.clone();
    
    extract(args).await.unwrap();
    
    // Files should be created
    assert!(css_path.exists());
    assert!(manifest_path.exists());
    
    // Verify CSS file has content
    let css_content = std::fs::read_to_string(&css_path).unwrap();
    assert!(!css_content.is_empty());
    assert!(css_content.contains("Generated by tailwind-extractor-cli"));
    
    // Verify manifest is valid JSON
    let manifest_content = std::fs::read_to_string(&manifest_path).unwrap();
    let manifest: serde_json::Value = serde_json::from_str(&manifest_content).unwrap();
    assert_eq!(manifest["metadata"]["version"], "1.0.0");
    assert!(manifest["classes"].is_object());
}

#[tokio::test]
async fn test_parallel_processing() {
    let fixtures_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("tests")
        .join("fixtures");
    let output_dir = TempDir::new().unwrap();
    
    let mut args = create_test_args(fixtures_dir.to_str().unwrap(), &output_dir);
    args.jobs = Some(2); // Use 2 threads
    
    let result = extract(args).await.unwrap();
    
    assert!(result.total_files_processed > 0);
    assert!(result.total_classes > 0);
}

#[tokio::test]
async fn test_verbose_mode() {
    let fixtures_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("tests")
        .join("fixtures");
    let output_dir = TempDir::new().unwrap();
    
    let mut args = create_test_args(fixtures_dir.to_str().unwrap(), &output_dir);
    args.verbose = true;
    
    // Just ensure it runs without panicking
    let result = extract(args).await.unwrap();
    assert!(result.total_classes > 0);
}

#[tokio::test]
async fn test_class_location_tracking() {
    let fixtures_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("tests")
        .join("fixtures");
    let output_dir = TempDir::new().unwrap();
    
    let args = create_test_args(fixtures_dir.to_str().unwrap(), &output_dir);
    
    let result = extract(args).await.unwrap();
    
    // Check classes in manifest have location info
    let classes = result.manifest["classes"].as_object().unwrap();
    
    // Should have classes with location info
    assert!(!classes.is_empty());
    
    // Check specific class has location info
    if let Some(bg_blue_info) = classes.get("bg-blue-500") {
        let files = bg_blue_info["files"].as_array().unwrap();
        assert!(!files.is_empty());
        
        // Location should have format "file:line:column"
        let first_loc = files[0].as_str().unwrap();
        // The location format is just the filename now, not with line:column
        assert!(first_loc.contains(".js") || first_loc.contains(".mjs"));
    }
}